---
layout: post
title: 字符串查找算法
---

字符串查找是很常见的功能, 但是实现一个高效的查找算法还是挺不容易的. 这两天花了点时间
理解了几种常见的算法 (KMP, BM, BMH a.k.a Horspool), 这里记录一下, 方便以后查找.

*[KMP]: Knuth–Morris–Pratt
*[BM]: Boyer-Moore
*[BMH]: Boyer-Moore-Horspool

### 约定

Pat: 模式字符串, Str: 待搜索的字符串.

## Brute-force

先介绍最容易理解的暴力破解法. 这算法比较直观, 就是将 Pat 与 Str 的字符一个个比较,
如果匹配失败就将 Pat 向右移动一位再进行比较, 直到匹配完成.

直接上算法

{% highlight java %}

public int bruteForce(String str, String pat) {
    int m = pat.length();
    int n = str.length();
    int i = 0, j = 0;

    while (j < m && i < n) {
        if (str.charAt(i) == pat.charAt(j)) {
            i++;
            j++;
            continue;
        }
        i = i - j + 1;
        j = 0;
    }

    if (j == m) {
        return i - j;
    }
    return -1;
}

{% endhighlight %}

## Knuth–Morris–Pratt

Brute-force 算法之所以不够高效是因为, 当匹配失败时, 部分匹配的字符会在 Pat 右移一位后再次比较,
这就带来了不必要的开销. KMP 算法就是在此基础上改进的.

Knuth 最开始的算法实现是基于 DFA (有限状态机)的, 假如 Pat 的长度为 M, 那么 DFA 的状态共有 M + 1

    Pat: abc
    DFA: (0) --a--> (1) --b--> (2) --c--> (3)

我们顺序读取 Str 的每个字符, 每读取一个就会改变 DFA 的状态, 当 DFA 处于 (3) 状态时就表示字符串
匹配完成

### 未完待续
