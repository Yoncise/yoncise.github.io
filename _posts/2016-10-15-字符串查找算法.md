---
layout: post
title: 字符串查找算法
---

字符串查找是很常见的功能, 但是实现一个高效的查找算法还是挺不容易的.
两天花了点时间理解了几种常见的算法 (KMP, BM, BMH a.k.a Horspool), 这里记录一下, 方便以后查找.

*[KMP]: Knuth–Morris–Pratt
*[BM]: Boyer-Moore
*[BMH]: Boyer-Moore-Horspool

### 约定

Pat: 模式字符串, Str: 待搜索的字符串.

## Brute-force

先介绍最容易理解的暴力破解法. 这算法比较直观, 就是将 Pat 与 Str 的字符一个个比较,
如果匹配失败就将 Pat 向右移动一位再进行比较, 直到匹配完成.

直接上算法

{% highlight java %}

public int bruteForce(String str, String pat) {
    int m = pat.length();
    int n = str.length();
    int i = 0, j = 0;

    while (j < m && i < n) {
        if (str.charAt(i) == pat.charAt(j)) {
            i++;
            j++;
            continue;
        }
        i = i - j + 1;
        j = 0;
    }

    if (j == m) {
        return i - j;
    }
    return -1;
}

{% endhighlight %}

## Knuth–Morris–Pratt

Brute-force 算法之所以不够高效是因为, 当匹配失败时, 部分匹配的字符会在 Pat 右移一位后再次比较,
这就带来了不必要的开销. KMP 算法就是在此基础上改进的.

Knuth 最开始的算法实现是基于 DFA (有限状态机) 的, 假如 Pat 的长度为 M, 那么 DFA 的状态共有 M + 1

    Pat: abc
    DFA: (0) --a--> (1) --b--> (2) --c--> (3)

我们顺序读取 Str 的每个字符, 每读取一个就会改变 DFA 的状态, 当 DFA 处于 `(3)` 状态时就表示字符串匹配完成.

假如 DFA 构造完成了, 那么我们该如何利用改造出来的 DFA 来搜索呢?

{% highlight java %}

class KMP {
    publiv int[][] initDfa(String pat) {
        // TODO
    }

    public int search(String pat, String str) {
        int[][] dfa = this.initDfa(pat);
        int j = 0;
        for (int i = 0; i < str.lenght(); i++) {
            char c = str.charAt(i);
            j = this.dfa[c - 'a'][j];
            if (j == pat.length()) {
                return i;
            }
        }
        return -1;
    }
}

{% endhighlight %}

有了 DFA 搜索就很简单了, 只用依次读取字符, 再从 DFA 里获取下一个状态就行了.

### 如何构造 DFA

KMP 算法最核心的问题就在于构造 DFA. 我们用一个矩阵来表示 DFA, 矩阵的行数为所有的可输入字符, 列数为 DFA 的状态数

以 `aba` 为例 (假设我们需要匹配的字符串只可能由 `abc` 组成), 我们会得到下面的 DFA

|可输入字符\Pat| a | b | a |
| - | - | - | - |
| a | 1 | 1 | 3 |
| b | 0 | 2 | 0 |
| c | 0 | 0 | 0 |

假如 Str 为 `acaba`, 那么依次读取字符, DFA 的状态变化为

    DFA[0][0]: 1
    DFA[1][2]: 0
    DFA[0][0]: 1
    DFA[1][1]: 2
    DFA[2][0]: 3

我们先考虑 DFA 的第一列 (状态 0), 只有当输入字符和 Pat 的第一个字符相同, DFA 才会进入 `(1)` 状态 (即匹配了一个字符),
其它任何字符都不会匹配, 所以 DFA 会停留在 (0) 状态 (即没有字符匹配)

下面我们考虑第二列 (状态 1), 只有当输入字符合 Pat 的第二个字符相同时, DFA 才会进入 `(2)` 状态, 那其它不匹配的字符呢?
可以这样思考, 当输入字符不匹配时, Pat 如果按照暴力破解法会右移一位, 此时 DFA 会进入 `(0)` 状态, 那么 `(2)`
状态在不匹配的时候的跳转情况和 `(0)` 状态是一样的.

最后考虑第三列 (状态 2), 同上, 只有匹配的时候才会进入 `(3)` 状态. 不匹配的时候, Pat 会右移一位, 此时 DFA 进入 `(0)`,
但是此时我们知道, 即将和 Pat 匹配的字符是 Pat 的第二个字符 (因为刚才匹配了), 所以 DFA 会进入 DFA[0][Pat[1]] 状态,
用上面的例子来说明就是, DFA[0][1] (`b` 在 Pat 中的 index 是 1), 即状态 `(0)`, 所以第三列不匹配的情况和状态里 `(0)` 
是一样的.

总结下就是, 当在某个状态不匹配时, DFA 会进入 `(0)` 状态 (右移一位), 这时我们可以根据已经匹配的字符 (除去第一个字符, 
因为 Pat 右移了一位) 来推断当匹配到当前字符时 DFA 会处于哪个状态. 本质也是一种递归的思想, 
我们可以根据之前状态的跳转规则来计算出当前状态的跳转规则.

最后构造 DFA 的算法实现如下:

{% highlight java %}

class KMP {
    private static final String ALPHABETS = "abc";

    private int[][] initDfa(String pat) {
        int m = pat.length();
        int r = KMP.ALPHABETS.length();
        int[][] dfa = new int[r][m]; // init with 0
        dfa[pat.charAt(0) - 'a'][0] = 1; // init first column
        int x = 0; // previous state
        for (int i = 1; i < pat.length(); i++) {
            for (int j = 0; j < r; j++) { // copy x state to current
                dfa[j][i] = dfa[j][x];
            }
            int ci = pat.charAt(i) - 'a';
            dfa[ci][i] = i + 1; // mached
            x = dfa[ci][x]; // update x
        }
        return dfa;
    }

    public int search(String pat, String str) {
        int[][] dfa = this.initDfa(pat);
        int j = 0;
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            j = dfa[c - 'a'][j];
            if (j == pat.length()) {
                return i - j + 1;
            }
        }
        return -1;
    }

}

{% endhighlight %}

算法里的 x 是比较重要的, 按照之前的描述我们是需要每次都回溯的, 但是因为 Pat 的字符串是不变的, 
也就是说, 每次回溯时前面的部分都是一样的, 所以用 x 记录一下省得每次都回溯.

这个就是 Knuth DFA 版的 KMP 算法, 我觉得这个版本是比较好理解的. 但这个版本有一个缺点就是, 
需要使用 MR (Pat 的长度乘以可输入字符的长度) 的额外空间. Pratt 在 Knuth 的 DFA 版本上改进了下, 只需要
额外使用 M 的空间 (即和可输入字符长度无关, 当然效率会低点), 于是就有了现在通常所说的 KMP 算法. 
(Morris 在 KMP 算法里做了什么? 呃, Wiki 的说法是, 
他是独立完成这个算法的. 总结就是, Knuth 完成了 DFA 版本的, Pratt 改进了, Morris 独立完成了)

### Pratt 改进版 (未完待续)
